// 변수 이름 + 개행
// 논리 / 구현 명세
// 구현은 간단히 -> 구체적
// 먼저 생각하기

// 구현
// 
// 뭉탱이로 개수 세기
// 1에서부터 n 자리수까지 올리는데 나온 1의 갯수 저장
// ex) 1 ~ 100 = 5
//     1 ~ 10 = 2
//	   1 ~ 1000 = 13
// dfs로 자리수마다 자리수 올리는데 필요한 1개수 구하기
// 0이면 현재 자릿수까지 자릿수올리는데 1의 개수 + 뒤의 이진수가 자리수 올리는데 썼던 1의 개수?
// 1이면 뒤의 이진수가 자리수 올리는데 썼던 1의 개수? 
// (x, 복잡하게 생각말자, 이렇게 계산하면 개수 안맞음)
// 
//1, 10, 11, 100, 101, 110, 111, 1000
//  1010010 + x
// 10000000
// x = 101110
//
//

//#include <iostream>
//#include <intrin.h>
//
//using LL = unsigned long long;
//
//LL num[2];
//LL dp[64] = {0, 1, 2};	//dp[i] : 0에서 i자리수에 1이 뜰 때까지 나오는 1의 갯수
//
//
//int main() {
//
//	std::cin >> num[0] >> num[1];
//	num[0]--;
//
//	for (int i = 3; i < 64; i++) {
//		for (int k = 1; k < i; k++) {
//			dp[i] += dp[k] + (1LL << (k - 1)) * (i - k - 1);	// k자리수까지 올리는데 나오는 경우의수 * 앞에 있는 1의 갯수
//		}
//		dp[i] += 1;
//
//	}
//
//	int oneCnt = 0;
//	LL res[2] = {0, };
//
//	for (int t = 0; t < 2; t++) {
//		oneCnt = 0;
//		for (int i = 64 - __lzcnt64(num[t]) - 1; i >= 0; i--) {
//			if (!((num[t] >> i) & 1)) continue;
//
//			res[t] += dp[i + 1] + (1LL << i) * oneCnt;
//			oneCnt++;
//		}
//	}
//
//	std::cout << res[1] - res[0];
//	return 0;
//}